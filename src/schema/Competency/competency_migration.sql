-- =====================================================
-- COMPETENCY SYSTEM FULL SETUP
-- =====================================================

-- =========================
-- 1. MASTER COMPETENCY
-- =========================
create table if not exists competency (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now(),
  competency_name text not null,
  days_active smallint, -- masa berlaku
  mandatory boolean default false,
  active boolean default true
);

-- =========================
-- 2. COMPETENCY â†” POSITION
-- =========================
create table if not exists competency_position (
  id bigint generated by default as identity primary key,
  competency_id bigint not null,
  position_id smallint not null,

  constraint fk_comp_pos_comp
    foreign key (competency_id) references competency(id) on delete cascade,

  constraint fk_comp_pos_position
    foreign key (position_id) references incumbent(id) on delete cascade,

  constraint unique_comp_position
    unique (competency_id, position_id)
);

-- =========================
-- 3. CURRENT STATUS
-- =========================
create table if not exists competency_mapping (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now(),

  nrp text not null,
  competency_id bigint not null,

  obtained_date date,
  expired_date date,
  active boolean default true,
  document_url text, -- Cache document URL
  latest_history_id bigint, -- Reference to the latest history record

  constraint fk_mapping_manpower
    foreign key (nrp) references manpower(nrp) on delete cascade,

  constraint fk_mapping_competency
    foreign key (competency_id) references competency(id) on delete cascade,

  constraint unique_manpower_competency
    unique (nrp, competency_id)
);

-- =========================
-- 4. TRAINING HISTORY
-- =========================
create table if not exists competency_history (
  id bigint generated by default as identity primary key,
  created_at timestamptz default now(),

  nrp text not null,
  competency_id bigint not null,

  training_date date not null,
  expired_date date,
  training_type text default 'renewal',
  note text,
  document_url text, -- Store document URL

  constraint fk_hist_manpower
    foreign key (nrp) references manpower(nrp) on delete cascade,

  constraint fk_hist_competency
    foreign key (competency_id) references competency(id) on delete cascade
);

-- Add Reference back to history (Circular dependency resolution)
do $$
begin
  if not exists (select 1 from information_schema.table_constraints where constraint_name = 'fk_mapping_history') then
    alter table competency_mapping 
    add constraint fk_mapping_history 
    foreign key (latest_history_id) references competency_history(id) on delete set null;
  end if;
end $$;

-- =====================================================
-- TRIGGER: AUTO UPDATE MAPPING
-- =====================================================
create or replace function fn_after_training_insert()
returns trigger
language plpgsql
as $$
declare
  v_days smallint;
  v_expired date;
begin

  select days_active
  into v_days
  from competency
  where id = new.competency_id;

  if new.expired_date is null and v_days is not null then
    v_expired := new.training_date + v_days;
  else
    v_expired := new.expired_date;
  end if;

  insert into competency_mapping (
    nrp,
    competency_id,
    obtained_date,
    expired_date,
    active,
    document_url,
    latest_history_id
  )
  values (
    new.nrp,
    new.competency_id,
    new.training_date,
    v_expired,
    true,
    new.document_url,
    new.id
  )
  on conflict (nrp, competency_id)
  do update set
    obtained_date = excluded.obtained_date,
    expired_date = excluded.expired_date,
    active = true,
    document_url = excluded.document_url,
    latest_history_id = excluded.latest_history_id;

  return new;
end;
$$;

drop trigger if exists trg_training_insert on competency_history;

create trigger trg_training_insert
after insert on competency_history
for each row
execute function fn_after_training_insert();

-- =====================================================
-- AUTO EXPIRE FUNCTION
-- =====================================================
create or replace function refresh_competency_expired()
returns void
language plpgsql
as $$
begin
  update competency_mapping
  set active = false
  where expired_date < current_date;
end;
$$;

-- =====================================================
-- DASHBOARD VIEW
-- =====================================================
create or replace view v_competency_status as
select
  cm.latest_history_id as id, -- Return the history ID for editing/deleting
  cm.nrp,
  mp.nama,
  cm.competency_id,
  c.competency_name,
  cm.obtained_date,
  cm.expired_date,
  cm.active,
  cm.document_url,
  case
    when cm.expired_date < current_date then 'expired'
    when cm.expired_date <= current_date + 30 then 'soon_expired'
    else 'valid'
  end as status
from competency_mapping cm
join manpower mp on mp.nrp = cm.nrp
join competency c on c.id = cm.competency_id;

-- =====================================================
-- RLS
-- =====================================================

alter table competency enable row level security;
alter table competency_mapping enable row level security;
alter table competency_history enable row level security;
alter table competency_position enable row level security;

-- =========================
-- POLICY: authenticated read
-- =========================
create policy "read competency"
on competency
for select
to authenticated
using (true);

create policy "read mapping"
on competency_mapping
for select
to authenticated
using (true);

create policy "read history"
on competency_history
for select
to authenticated
using (true);

-- =========================
-- POLICY: insert training
-- =========================
create policy "insert training"
on competency_history
for insert
to authenticated
with check (true);

-- =========================
-- SERVICE ROLE FULL ACCESS
-- =========================
create policy "service full competency"
on competency
for all
to service_role
using (true)
with check (true);

create policy "service full mapping"
on competency_mapping
for all
to service_role
using (true)
with check (true);

create policy "service full history"
on competency_history
for all
to service_role
using (true)
with check (true);

create policy "service full comp pos"
on competency_position
for all
to service_role
using (true)
with check (true);

-- =====================================================
-- GRANT RPC
-- =====================================================
grant execute on function refresh_competency_expired() to service_role;


-- Izin untuk tabel competency
create policy "insert competency" on competency for insert to authenticated with check (true);
create policy "update competency" on competency for update to authenticated using (true);
create policy "delete competency" on competency for delete to authenticated using (true);

-- Izin untuk tabel competency_position (karena frontend melakukan sync posisi)
create policy "read competency_position" on competency_position for select to authenticated using (true);
create policy "insert competency_position" on competency_position for insert to authenticated with check (true);
create policy "delete competency_position" on competency_position for delete to authenticated using (true);


-- Pastikan RLS Aktif
ALTER TABLE public.competency_history ENABLE ROW LEVEL SECURITY;

-- Tambahkan Policy SELECT jika belum ada
CREATE POLICY "Allow view" ON public.competency_history FOR SELECT TO authenticated USING (true);